---
title: "Assignment3"
author: "Marina Ramírez Baños, Giovanni Vincenzo Cavallo, Pablo Bondia Portoles, Priyanka Anantha Narayanan"
date: "2024-11-05"
output: html_document
---
# Brief explanation of our idea 

Our idea is to merge to different datasets together to find out if there is correlation between corruption in countries and the amount of non-religious people in those same countries. 
One dataset has demographic information about religion in different countries; the other dataset contains information about the Corruption Perceived Index (CPI) in those countries. 
 *Greater* values of CPI correspond to a less perceived corruption in the country.
 


# Import data

```{r}
# Load tidyverse and readr packages

library(tidyverse)
library(readr)

# Import religion_by_country and corruption_by_country datasets

religion_by_country <- read_csv("religion-by-country-2024.csv")
corruption_by_country <- read_delim("CPI2020_for_merge.csv", delim = ";", escape_double = FALSE, trim_ws = TRUE)
corruption_by_country$`CPI score 2020`<- as.numeric(corruption_by_country$`CPI score 2020`) #Changing the column type from chr to numeric
class(corruption_by_country$`CPI score 2020`) 
```

We must filter the "religion_by_country" dataset to include only the data from 2020, as is the data we have in the "corruption_by_country" dataset.


```{r}
# We have missing data for 2020 for United State, so we are gonna use the data from 2010 as an alternative

religion_by_country[religion_by_country$country == "United States", c("ReligionByCountry_TotalReligious_2020",  "religionByCountry_christians_2020", 
"religionByCountry_muslims_2020", "religionByCountry_hindus_2020", 
"religionByCountry_buddhists_2020", "religionByCountry_folkReligions_2020", 
"religionByCountry_jews_2020", "religionByCountry_other_2020", 
"religionByCountry_unaffiliated_2020")] <- religion_by_country[religion_by_country$country == "United States", c("total", "religionByCountry_christians", 
"religionByCountry_muslims", "religionByCountry_hindus", 
"religionByCountry_buddhists", "religionByCountry_folkReligions", 
"religionByCountry_jews", "religionByCountry_other", 
"religionByCountry_unaffiliated")]

#This piece of code copies the data for United States from 2010 into 2020 columns
```


```{r}

dput(names(religion_by_country))


# Filter religion_by_country dataset only including the data from 2020

religion_by_country <- religion_by_country %>% select("country", "ReligionByCountry_TotalReligious_2020",  "religionByCountry_christians_2020", 
"religionByCountry_muslims_2020", "religionByCountry_hindus_2020", 
"religionByCountry_buddhists_2020", "religionByCountry_folkReligions_2020", 
"religionByCountry_jews_2020", "religionByCountry_other_2020", 
"religionByCountry_unaffiliated_2020")



```

We create a dataset "percentage_religion_by_country", which includes the percentage of people of each religion over the total population of the country.

```{r}
# Create new columns

#Total population
percentage_religion_by_country <- religion_by_country %>% mutate(
  total_population = ReligionByCountry_TotalReligious_2020 + religionByCountry_unaffiliated_2020
)

#Proportion of individuals from each religion
percentage_religion_by_country <- percentage_religion_by_country %>% mutate(
  percentage_ReligionByCountry_TotalReligious_2020 = ((ReligionByCountry_TotalReligious_2020
)/total_population)*100,
  percentage_religionByCountry_christians_2020 = ((religionByCountry_christians_2020
)/total_population)*100,
percentage_religionByCountry_muslims_2020 =((religionByCountry_muslims_2020
)/total_population)*100,
percentage_religionByCountry_hindus_2020 = ((religionByCountry_hindus_2020
)/total_population)*100,
percetage_religionByCountry_buddhists_2020 = ((religionByCountry_buddhists_2020
)/total_population)*100,
percentage_religionByCountry_folkReligions_2020 = ((religionByCountry_folkReligions_2020
)/total_population)*100,
percentage_religionByCountry_jews_2020 = ((religionByCountry_jews_2020
)/total_population)*100,
percentage_religionByCountry_other_2020 = ((religionByCountry_other_2020
)/total_population)*100,
percentage_religionByCountry_unaffiliated_2020 = ((religionByCountry_unaffiliated_2020
)/total_population)*100
)

# Remove the other columns that do not include the proportions of individuals
percentage_religion_by_country <- percentage_religion_by_country %>% select(-starts_with("religion", ignore.case = TRUE))

```

# Merging datasets

To merge both datasets we have to use a variable they have in common. In our case, that variable is "country". However, we firstly need to rename "Country" in the corruption_by_country dataset to "country", as it is in the percentage_religion_by_country dataset.

```{r}
# Rename "Country" to "country" from corruption_by_country dataset

corruption_by_country <- corruption_by_country %>% rename(country = Country)

# Use full_join() from tidyverse to merge the datasets by country. By doing that, if a country is included in the dataset 1 but not in dataset 2, the columms of dataset 2 will contain "NA" values for that rows and viceversa

merged_dataset <- full_join(percentage_religion_by_country, corruption_by_country, by = "country")

```

# Tidying data

For the purpose of the analysis, we want to exclude those countries that do not show data about the amount of religious population in 2020 or have a NA value for CPI score 2020.


```{r}
# Remove from merged_dataset those countries with NA values for total_population

merged_dataset <- merged_dataset %>% filter(!is.na(total_population))

# Remove from merged_dataset those countries with NA values for CPI score 2020

merged_dataset <- merged_dataset %>% filter(!is.na(`CPI score 2020`))

# Removing spaces
merged_dataset <- janitor::clean_names(merged_dataset)

```

# Correlation Analysis

We need to check for these assumptions if we want to perform a correlation test:
* Linearity: There should be a linear relationship between the two variables. Correlation only measures linear relationships.
* Normality (for parametric correlation tests like Pearson): The two variables should ideally follow a normal distribution. This is especially important for smaller sample sizes.
* No Outliers: Outliers can significantly distort the correlation coefficient.

## Linearity

```{r}
plot(merged_dataset$percentage_religion_by_country_unaffiliated_2020, merged_dataset$cpi_score_2020, main = "Scatter Plot", xlab = "Non Religious People", ylab = "CPI score")
abline(lm(merged_dataset$cpi_score_2020 ~ merged_dataset$percentage_religion_by_country_unaffiliated_2020), col = "blue") # Adds a linear regression line
```
## Normality
```{r}
# CPI
qqnorm(merged_dataset$cpi_score_2020, y = 'CPI Score Index')
qqline(merged_dataset$cpi_score_2020)
# Non_Religious
qqnorm(merged_dataset$percentage_religion_by_country_unaffiliated_2020, ylab = 'Percentage Non-Religious People by Country')
qqline(merged_dataset$percentage_religion_by_country_unaffiliated_2020)


```
## Homoscedasticity 

```{r}
model <- lm(merged_dataset$cpi_score_2020 ~ merged_dataset$percentage_religion_by_country_unaffiliated_2020)
ggplot()+
  aes(x = fitted(model), y = resid(model)) +
  geom_point()+
  geom_smooth(se = FALSE) + geom_abline(slope = 0)
```
## Outlayers

```{r}

```


```{r}

# Coline's code
library(ggResidpanel)

lm_unaffiliated <- lm(percentage_religion_by_country_unaffiliated_2020 ~ cpi_score_2020, data = merged_dataset)
resid_panel(lm_unaffiliated)
```

